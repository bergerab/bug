"TODO change WD to root"

"hack for SDL_tff.dll it won't load unless it has other DLLs in the same directory as it"
(impl:change-directory "..")

"Cons helpers that should probably be builtins"
(impl:function cadr (x)
	"Gets the second item in a list."
  (car (cdr x)))

(impl:function caddr (x)
	"Gets the third item in a list."
  (car (cdr (cdr x))))

(impl:function cadddr (x)
	"Gets the fourth item in a list."
  (car (cdr (cdr (cdr x)))))

(impl:function caddddr (x)
	"Gets the fifth item in a list."
  (car (cdr (cdr (cdr (cdr x))))))

(impl:function caar (x)
	"Gets the first item in the nested list of a list of lists."
  (car (car x)))

(impl:function cddr (x)
	"Skips the first two items in a list."
  (cdr (cdr x)))

(impl:function nil? (x)
	"Is x nil?"
	(= x nil))

(impl:function list? (x)
	"Is x a list (either cons cell or nil)?"
  (let ((type (impl:type-of x)))
    (or (= type 'cons)
        (= type nil))))

(impl:function cons? (x)
	"Is x a cons cell?"
  (let ((type (impl:type-of x)))
    (= type 'cons)))

(impl:function mapcar (f xs)
	"Applies f to each item in the list xs and returns a new list containing the yielded values."
	(if xs
		(cons (impl:call f (car xs)) 
				  (mapcar f (cdr xs)))
		nil))

(impl:function foreach (f xs)
	(if xs
		(progn
			(impl:call f (car xs))
			(foreach f (cdr xs)))
		nil))

(impl:function concat (xs ys)
	"Creates a new single list that contains all items in xs followed by all items in ys (maintains ordering)."
	(if xs
		(cons (car xs) (concat (cdr xs) ys))
			(if ys
				(cons (car ys) (concat xs (cdr ys)))
					nil)))

(impl:function concatn (lists)
	(do-concatn (car lists) (cdr lists)))

(impl:function do-concatn (list lists)
	(if list
		(cons (car list) (do-concatn (cdr list) lists))
		(if lists
			(do-concatn (car lists) (cdr lists))
			nil)))

(impl:function unquoted? (x)
	"Does x have the form (UNQUOTE ...)?"
	(if (list? x)
	    (= (car x) 'unquote)
	  nil))

(impl:function unquote-spliced? (x)
	"Does x have the form (UNQUOTE-SPLICING ...)?"
	(if (list? x)
	    (= (car x) 'unquote-splicing)
	  nil))

(impl:function do-quasiquote (x)
	"
	Takes any expression x and returns the quasiquoted result.
	Quasiquoting indicates that the given expression's quoting rules will be
	flipped. Any non-quoted expression will become quoted, and you must explicitly
	unquote expressions to indicate that they should be evaluated. There is a special
	case where you can indicate that an expression should be evaluated, and the value
	(which is a assumed to be a list) will be concatenated to the list it is contained in
	this is called UNQUOTE-SPLICING.

	Examples:
		(quasiquote 2) => (quote 2)
		(quasiquote (a b c)) => (quote (a b c))
		(quasiquote (unquote (my-function 1 2))) => (my-function 1 2)
		(quasiquote (list (unquote (+ 1 2)) 4)) => (list 3 (quote 4))
		(quasiquote (+ (unquote-splicing (list 1 2)))) => (+ 1 2)

	Note that the reader usually provides a special syntax for quasiquoting that looks like this:

	Examples (using quasiquoting syntax):
		`2 => 2
		`(a b c) => (a b c)
		`,(my-function 1 2) => (my-function 1 2)
		`(list ,(+ 1 2) 4) => (list 3 4)
		`(+ ,@(list 1 2)) => (+ 1 2)

	The implementation wraps all the values in an additional list to make it easier to
	apply a UNQUOTE-SPLICING.
	"
	(if (unquoted? x)
		     (list (cadr x))
		   (if (unquote-spliced? x)
		       (list (cadr x))
		     (if (cons? x)
				   	(list (concatn (mapcar (symbol-function 'do-quasiquote) x)))
		       (list (list 'quote x))))))

"(impl:macro quasiquote (x)
	(car (do-quasiquote x)))"

"===================== misc =========================="
"why does (fib 10) crash?"
(impl:function fib (x)
  (if (< x 2)
    x
    (+ (fib (- x 2)) 
       (fib (- x 1)))))
"====================================================="

"================= mydll library ====================="
"FFI testing"
(impl:struct 'mydll-ivec2
	'((x int)
	  (y int)))

(impl:struct 'mydll-rect
	'((x int)
	  (y int)
		(w int)
		(h int)))

(impl:struct 'mydll-quad
	'((w int)
	  (x int)
		(y int)
		(z int)))

(impl:struct 'mydll-tri
	'((x uint8)
	  (y uint8)
		(z uint8)))

(impl:struct 'mydll-color
	'((r uint8)
	  (g uint8)
		(b uint8)
		(a uint8)))

(set 'mydll (impl:dynamic-library "../experiments/mydll/mydll.dll"))

(set-symbol-function 'print-rect2
	(impl:foreign-function
  	mydll 'print_rect2
  	'int '(mydll-rect mydll-rect)))

(set-symbol-function 'print-me
	(impl:foreign-function
  	mydll 'print_me
  	'int '()))

(set-symbol-function 'multitest
	(impl:foreign-function
  	mydll 'multitest
  	'int '(mydll-rect pointer mydll-color)))

(set-symbol-function 'print-rect
	(impl:foreign-function
  	mydll 'print_rect
  	'void '(mydll-rect)))

(set-symbol-function 'print-4
	(impl:foreign-function
  	mydll 'print_four
  	'void '(mydll-quad)))

(set-symbol-function 'print-3
	(impl:foreign-function
  	mydll 'print_three
  	'void '(mydll-tri)))

(set-symbol-function 'print-color
	(impl:foreign-function
  	mydll 'print_color
  	'void '(mydll-color)))

(set-symbol-function 'print-ivec2
	(impl:foreign-function
  	mydll 'print_ivec2
  	'void '(mydll-ivec2)))

"========================================================"

(impl:function struct-test ()
	(impl:struct 'rect
		'((x int) (y int) (w int) (h int)))

	(set 'rect (impl:alloc-struct (impl:symbol-type 'rect)))
	(impl:set-struct-field rect 'x 10)
	(impl:set-struct-field rect 'y 20)
	(impl:set-struct-field rect 'w 200)
	(impl:set-struct-field rect 'h 100)

	(print rect)

	(print (impl:struct-field rect 'x))
	(print (impl:struct-field rect 'y))
	(print (impl:struct-field rect 'w))
	(print (impl:struct-field rect 'h))
	(impl:set-struct-field rect 'w 23)
	(print (impl:struct-field rect 'w)))