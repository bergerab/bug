"Cons helpers that should probably be builtins"
(impl:define-function cadr (x)
	"Gets the second item in a list."
  (car (cdr x)))

(impl:define-function caddr (x)
	"Gets the third item in a list."
  (car (cdr (cdr x))))

(impl:define-function cadddr (x)
	"Gets the fourth item in a list."
  (car (cdr (cdr (cdr x)))))

(impl:define-function caddddr (x)
	"Gets the fifth item in a list."
  (car (cdr (cdr (cdr (cdr x))))))

(impl:define-function caar (x)
	"Gets the first item in the nested list of a list of lists."
  (car (car x)))

(impl:define-function cddr (x)
	"Skips the first two items in a list."
  (cdr (cdr x)))

(impl:define-function nil? (x)
	"Is x nil?"
	(= x nil))

(impl:define-function list? (x)
	"Is x a list (either cons cell or nil)?"
    (or (= (type-of x) (symbol-type 'cons))
        (= x nil)))

(impl:define-function cons? (x)
	"Is x a cons cell?"
    (= (type-of x) (symbol-type 'cons)))

(impl:define-function mapcar (f xs)
	"Applies f to each item in the list xs and returns a new list containing the yielded values."
	(if xs
		(cons (call f (car xs)) 
				  (mapcar f (cdr xs)))
		nil))

(impl:define-function concat (xs ys)
	"Creates a new single list that contains all items in xs followed by all items in ys (maintains ordering)."
	(if xs
		(cons (car xs) (concat (cdr xs) ys))
			(if ys
				(cons (car ys) (concat xs (cdr ys)))
					nil)))

(impl:define-function concatn (lists)
	(do-concatn (car lists) (cdr lists)))

(impl:define-function do-concatn (list lists)
	(if list
		(cons (car list) (do-concatn (cdr list) lists))
		(if lists
			(do-concatn (car lists) (cdr lists))
			nil)))

(impl:define-function unquoted? (x)
	"Does x have the form (UNQUOTE ...)?"
	(if (list? x)
	    (= (car x) 'unquote)
	  nil))

(impl:define-function unquote-spliced? (x)
	"Does x have the form (UNQUOTE-SPLICING ...)?"
	(if (list? x)
	    (= (car x) 'unquote-splicing)
	  nil))

(impl:define-function do-quasiquote (x)
	"
	Takes any expression x and returns the quasiquoted result.
	Quasiquoting indicates that the given expression's quoting rules will be
	flipped. Any non-quoted expression will become quoted, and you must explicitly
	unquote expressions to indicate that they should be evaluated. There is a special
	case where you can indicate that an expression should be evaluated, and the value
	(which is a assumed to be a list) will be concatenated to the list it is contained in
	this is called UNQUOTE-SPLICING.

	Examples:
		(quasiquote 2) => (quote 2)
		(quasiquote (a b c)) => (quote (a b c))
		(quasiquote (unquote (my-function 1 2))) => (my-function 1 2)
		(quasiquote (list (unquote (+ 1 2)) 4)) => (list 3 (quote 4))
		(quasiquote (+ (unquote-splicing (list 1 2)))) => (+ 1 2)

	Note that the reader usually provides a special syntax for quasiquoting that looks like this:

	Examples (using quasiquoting syntax):
		`2 => 2
		`(a b c) => (a b c)
		`,(my-function 1 2) => (my-function 1 2)
		`(list ,(+ 1 2) 4) => (list 3 4)
		`(+ ,@(list 1 2)) => (+ 1 2)

	The implementation wraps all the values in an additional list to make it easier to
	apply a UNQUOTE-SPLICING.
	"
	(if (unquoted? x)
 	 (list 'list (cadr x))
   (if (unquote-spliced? x)
     (cadr x)
     (if (cons? x)
	     (list 'list (concat (list 'concatn) (list (concat (list 'list) (mapcar (symbol-function 'do-quasiquote) x)))))
       (list 'list (list 'quote x))))))

(macro quasiquote (x)
	(cadr (do-quasiquote x)))

(macro when args
	`(if ,(car args)
			(progn 
				,@(cdr args))
				nil))

(macro unless args
	`(when (= nil ,(car args)) 
			,@(cdr args)))

(macro setq (sym val)
	`(set ',sym ,val))

(macro make (type)
	`(alloc-struct ',type))

(macro setf (instance field value)
	`(set-struct-field ,instance ',field , value))

(macro getf (instance field)
	`(struct-field ,instance ',field))

(macro function args
	`(impl:define-function ,@args))

(macro print-return (x)
	`(let ((i-need-to-implement-gensym ,x))
		(print i-need-to-implement-gensym)
		i-need-to-implement-gensym))

(macro struct (name fields)
	`(impl:define-struct ',name ',fields))


(function mapcar-with-carry (f xs carry)
	"mapcar with a value that is carried to the function -- a total hack should be removed when bug compiler is done (using closures or builtin looping constructs)"
	(when xs
		(cons (call f (car xs) carry) 
				  (mapcar-with-carry f (cdr xs) carry))))
(function with-fields-format-field (field instance)
	`(,field (getf ,instance ,field)))

(macro with-fields args
	(let ((fields (cadr args))
	      (instance (car args))
				(body (cddr args)))
(print (mapcar-with-carry (symbol-function 'with-fields-format-field) fields instance))
    (print-return 
			`(let ((i-need-to-implement-gensym-real-bad ,instance)) 
					(let (,@(mapcar-with-carry (symbol-function 'with-fields-format-field) fields 'i-need-to-implement-gensym-real-bad))
    				,@body)))))

"TODO: make macroexpand builtin"

"===================== misc =========================="
(function fib (x)
  (if (< x 2)
    x
    (+ (fib (- x 2)) 
       (fib (- x 1)))))
"====================================================="

(struct rect
	((x int) (y int) (w int) (h int)))

(function struct-test ()
	(setq rect (make rect))
	(setf rect x 10)
	(setf rect y 20)
	(setf rect w 200)
	(setf rect h 100)

	(print rect)

	(print (getf rect x))
	(print (getf rect y))
	(print (getf rect w))
	(print (getf rect h))
	(setf rect w 3)
	(print (getf rect w)))

(function advanced-struct-test ()
  (struct b
   ((z int)
    (a int)
  	(b int)
  	(c int)
  	(d int)))
  
" TODO: this should be OK to say (pointer b)"
  (struct a
   ((x int) 
    (y (pointer b))))
  
  (make a)
  (getf (make a) y))

"TODO change WD to root"

"
Load BUGED
"

"this shouldn't be done runtime -- when bug compiler is written in bug that will be easier to do"
(function load (path)
	(let ((file (open-file path "rb")))
		(let ((f (compile-entire-file file)))
			(call f))))

(load "../experiments/mydll/mydll.bug")

(impl:change-directory "../buged/")
(load "main.bug")
