(impl:function find-package (sd)
	"Sets the current package to be the package named by the given string designator."
  (let ((p (impl:find-package sd)))
    (if p p (print "error: package not found " sd))))

"Cons helpers that should probably be builtins"
(impl:function cadr (x)
	"Gets the second item in a list."
  (car (cdr x)))

(impl:function caddr (x)
	"Gets the third item in a list."
  (car (cdr (cdr x))))

(impl:function cadddr (x)
	"Gets the fourth item in a list."
  (car (cdr (cdr (cdr x)))))

(impl:function caddddr (x)
	"Gets the fifth item in a list."
  (car (cdr (cdr (cdr (cdr x))))))

(impl:function caar (x)
	"Gets the first item in the nested list of a list of lists."
  (car (car x)))

(impl:function cddr (x)
	"Skips the first two items in a list."
  (cdr (cdr x)))

(impl:function nil? (x)
	"Is x nil?"
	(= x nil))

(impl:function list? (x)
	"Is x a list (either cons cell or nil)?"
  (let ((type (impl:type-of x)))
    (or (= type 'cons)
        (= type nil))))

(impl:function cons? (x)
	"Is x a cons cell?"
  (let ((type (impl:type-of x)))
    (= type 'cons)))

(impl:function mapcar (f xs)
	"Applies f to each item in the list xs and returns a new list containing the yielded values."
	(if xs
		(cons (impl:call f (car xs)) 
				  (mapcar f (cdr xs)))
		nil))

(impl:function foreach (f xs)
	(if xs
		(progn
			(impl:call f (car xs))
			(foreach f (cdr xs)))
		nil))

(impl:function concat (xs ys)
	"Creates a new single list that contains all items in xs followed by all items in ys (maintains ordering)."
	(if xs
		(cons (car xs) (concat (cdr xs) ys))
			(if ys
				(cons (car ys) (concat xs (cdr ys)))
					nil)))

(impl:function concatn (lists)
	(do-concatn (car lists) (cdr lists)))

(impl:function do-concatn (list lists)
	(if list
		(cons (car list) (do-concatn (cdr list) lists))
		(if lists
			(do-concatn (car lists) (cdr lists))
			nil)))

(impl:function unquoted? (x)
	"Does x have the form (UNQUOTE ...)?"
	(if (list? x)
	    (= (car x) 'unquote)
	  nil))

(impl:function unquote-spliced? (x)
	"Does x have the form (UNQUOTE-SPLICING ...)?"
	(if (list? x)
	    (= (car x) 'unquote-splicing)
	  nil))

(impl:function do-quasiquote (x)
	"
	Takes any expression x and returns the quasiquoted result.
	Quasiquoting indicates that the given expression's quoting rules will be
	flipped. Any non-quoted expression will become quoted, and you must explicitly
	unquote expressions to indicate that they should be evaluated. There is a special
	case where you can indicate that an expression should be evaluated, and the value
	(which is a assumed to be a list) will be concatenated to the list it is contained in
	this is called UNQUOTE-SPLICING.

	Examples:
		(quasiquote 2) => (quote 2)
		(quasiquote (a b c)) => (quote (a b c))
		(quasiquote (unquote (my-function 1 2))) => (my-function 1 2)
		(quasiquote (list (unquote (+ 1 2)) 4)) => (list 3 (quote 4))
		(quasiquote (+ (unquote-splicing (list 1 2)))) => (+ 1 2)

	Note that the reader usually provides a special syntax for quasiquoting that looks like this:

	Examples (using quasiquoting syntax):
		`2 => 2
		`(a b c) => (a b c)
		`,(my-function 1 2) => (my-function 1 2)
		`(list ,(+ 1 2) 4) => (list 3 4)
		`(+ ,@(list 1 2)) => (+ 1 2)

	The implementation wraps all the values in an additional list to make it easier to
	apply a UNQUOTE-SPLICING.
	"
	(if (unquoted? x)
		     (list (cadr x))
		   (if (unquote-spliced? x)
		       (list (cadr x))
		     (if (cons? x)
				   	(list (concatn (mapcar (symbol-function 'do-quasiquote) x)))
		       (list (list 'quote x))))))

"(impl:macro quasiquote (x)
	(car (do-quasiquote x)))"

"===================== misc =========================="
"why does (fib 10) crash?"
(impl:function fib (x)
  (if (< x 2)
    x
    (+ (fib (- x 2)) 
       (fib (- x 1)))))
"====================================================="

"================= mydll library ====================="
"FFI testing"
(impl:struct 'mydll-ivec2
	'((x ffi:int)
	  (y ffi:int)))

(impl:struct 'mydll-rect
	'((x ffi:int)
	  (y ffi:int)
		(w ffi:int)
		(h ffi:int)))

(impl:struct 'mydll-quad
	'((w ffi:int)
	  (x ffi:int)
		(y ffi:int)
		(z ffi:int)))

(impl:struct 'mydll-tri
	'((x ffi:uint8)
	  (y ffi:uint8)
		(z ffi:uint8)))

(impl:struct 'mydll-tri
	'((r ffi:uint8)
	  (g ffi:uint8)
		(b ffi:uint8)
		(a ffi:uint8)))

(set 'mydll (impl:dynamic-library "experiments/mydll/mydll.dll"))

(set-symbol-function 'print-rect2
	(impl:foreign-function
  	mydll 'print_rect2
  	'ffi:int (list mydll-rect mydll-rect)))

(set-symbol-function 'print-me
	(impl:foreign-function
  	mydll 'print_me
  	'ffi:int nil))

(set-symbol-function 'multitest
	(impl:foreign-function
  	mydll 'multitest
  	'ffi:int (list mydll-rect 'ffi:* mydll-color)))

(set-symbol-function 'print-rect
	(impl:foreign-function
  	mydll 'print_rect
  	'ffi:void (list mydll-rect)))

(set-symbol-function 'print-4
	(impl:foreign-function
  	mydll 'print_four
  	'ffi:void (list mydll-4)))

(set-symbol-function 'print-3
	(impl:foreign-function
  	mydll 'print_three
  	'ffi:void (list mydll-3)))

(set-symbol-function 'print-color
	(impl:foreign-function
  	mydll 'print_color
  	'ffi:void (list mydll-color)))

(set-symbol-function 'print-ivec2
	(impl:foreign-function
  	mydll 'print_ivec2
  	'ffi:void (list mydll-ivec2)))

"========================================================"

"================= sdl2 library ====================="
(impl:struct 'sdl-rect
	'((x ffi:int)
		(y ffi:int)
		(w ffi:int)
		(h ffi:int)))

(impl:struct 'sdl-keysym
	'((scancode ffi:uint8)
		(sym ffi:int)
		(mod ffi:int)
		(unicode ffi:uint16)))

(impl:struct 'sdl-keyboard-event
	'((type ffi:uint8)
		(state ffi:uint8)
		(keysym sdl-keysym)))

(set 'sdl2 (impl:dynamic-library "experiments/sdl/SDL2.dll"))

(set-symbol-function 'init
  (impl:foreign-function
  	sdl2 'SDL_Init
  	'ffi:int '(ffi:int)))

(set-symbol-function 'create-window
  (impl:foreign-function
  	sdl2 'SDL_CreateWindow
    'ffi:* '((ffi:* ffi:char) ffi:int ffi:int ffi:int ffi:int ffi:int)))

(set-symbol-function 'create-renderer
  (impl:foreign-function
  	sdl2 'SDL_CreateRenderer
    'ffi:* '(ffi:* ffi:int ffi:int)))

(set-symbol-function 'get-error
  (impl:foreign-function
  	sdl2 'SDL_GetError
    '(ffi:* ffi:char) '()))

(set-symbol-function 'rw-from-file
  (impl:foreign-function
  	sdl2 'SDL_RWFromFile
    'ffi:* '((ffi:* ffi:char) (ffi:* ffi:char))))

(set-symbol-function 'load-bmp-rw
  (impl:foreign-function
  	sdl2 'SDL_LoadBMP_RW
    'ffi:* '(ffi:* ffi:int)))

(set-symbol-function 'create-texture-from-surface
  (impl:foreign-function
  	sdl2 'SDL_CreateTextureFromSurface
    'ffi:* '(ffi:* ffi:*)))

(set-symbol-function 'render-clear
  (impl:foreign-function
  	sdl2 'SDL_RenderClear
    'ffi:* '(ffi:*)))

(set-symbol-function 'render-copy
  (impl:foreign-function
  	sdl2 'SDL_RenderCopy
    'ffi:* (list 'ffi:* 'ffi:* 'sdl-rect 'sdl-rect)))

(set-symbol-function 'render-present
  (impl:foreign-function
  	sdl2 'SDL_RenderPresent
    'ffi:* '(ffi:*)))

(set-symbol-function 'delay
  (impl:foreign-function
  	sdl2 'SDL_Delay
    'ffi:int '(ffi:int)))
"========================================================"

"================= sdl2-tff library ====================="
(impl:struct 'sdl-color
	'((r ffi:uint8)
		(g ffi:uint8)
		(b ffi:uint8)
		(a ffi:uint8)))

(set 'sdl2-ttf (impl:dynamic-library "SDL2_ttf.dll"))

(set-symbol-function 'ttf-init
  (impl:foreign-function
  	sdl2-ttf 'TTF_Init
    'ffi:int '()))
(set-symbol-function 'open-font
  (impl:foreign-function
  	sdl2-ttf 'TTF_OpenFont
    'ffi:* '(ffi:* ffi:int)))
(set-symbol-function 'render-text-solid
  (impl:foreign-function
  	sdl2-ttf 'TTF_RenderText_Solid
    'ffi:* (list 'ffi:* 'ffi:* 'sdl-color)))

"helper functions"

(impl:function load-bmp (path)
	(let ((bmp-file (rw-from-file path "rb")))
		(load-bmp-rw bmp-file 1)))

(impl:function load-bmp-tex (ren path)
	(create-texture-from-surface ren (load-bmp path)))
"========================================================"

(impl:function make-text (x y message)
	(let ((surface (render-text-solid *font* message *font-color*)))
		(let ((texture (create-texture-from-surface *renderer* surface)))
			(list :text x y texture message))))

(impl:function get-text-x (text)
	(cadr text))

(impl:function get-text-y (text)
	(caddr text))

(impl:function get-text-texture (text)
	(cadddr text))

(impl:function get-text-message (text)
	(caddddr text))

(impl:function render-text (x y message)
	(render (make-text x y message)))

(impl:function render (object)
	(if (= (car object) :text)
		(render-copy *renderer* (get-text-texture object) nil 
				(list (get-text-x object) (get-text-y object) 
				 	    (* *font-size* 5) *font-size*))
		nil))

(impl:function render-loop (x)
	(render-clear *renderer*)
	(set '*font-color* (list x 0 255 0))
	(render-text 0 10 "hello")
	(set '*font-color* (list x 0 0 0))
	(render-text 100 200 "hello")
	(render-present *renderer*)
	(delay 100)
	(render-loop (+ x 1)))

(impl:function sdl-test ()
	(init 3)

	(set '*window* (create-window "Hello World!" 100 100 620 387 4))
	(set '*renderer* (create-renderer *window* 0 2))

	(set 'cat (load-bmp-tex *renderer* "experiments/sdl/grumpy-cat.bmp"))

	(if (nil? (ttf-init))
		(print "SDL_TTF failed to initialize.")
		nil)

	(set '*font-size* 64)
	(set '*font* (open-font "iosevka.ttf" *font-size*))
	(set '*font-color* '(255 255 255 0))

	(render-loop 0))

(impl:function struct-test ()
	(set 'rect (impl:alloc-struct (impl:symbol-struct 'sdl-rect)))
	(impl:set-struct-field rect 'x 10)
	(impl:set-struct-field rect 'y 20)
	(impl:set-struct-field rect 'w 200)
	(impl:set-struct-field rect 'h 100)

	(print rect)

	(print (impl:struct-field rect 'x))
	(print (impl:struct-field rect 'y))
	(print (impl:struct-field rect 'w))
	(print (impl:struct-field rect 'h)))