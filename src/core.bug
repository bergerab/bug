(impl:function find-package (sd)
	"Sets the current package to be the package named by the given string designator."
  (let ((p (impl:find-package sd)))
    (if p p (print "error: package not found " sd))))

"Cons helpers that should probably be builtins"
(impl:function cadr (x)
	"Gets the second item in a list."
  (car (cdr x)))

(impl:function caar (x)
	"Gets the first item in the nested list of a list of lists."
  (car (car x)))

(impl:function cddr (x)
	"Skips the first two items in a list."
  (cdr (cdr x)))

(impl:function nil? (x)
	"Is x nil?"
	(= x nil))

(impl:function list? (x)
	"Is x a list (either cons cell or nil)?"
  (let ((type (impl:type-of x)))
    (or (= type 'cons)
        (= type nil))))

(impl:function cons? (x)
	"Is x a cons cell?"
  (let ((type (impl:type-of x)))
    (= type 'cons)))

(impl:function mapcar (f xs)
	"Applies f to each item in the list xs and returns a new list containing the yielded values."
	(if xs
		(cons (impl:call f (car xs)) 
				  (mapcar f (cdr xs)))
		nil))

(impl:function foreach (f xs)
	(if xs
		(progn
			(impl:call f (car xs))
			(foreach f (cdr xs)))
		nil))

(impl:function concat (xs ys)
	"Creates a new single list that contains all items in xs followed by all items in ys (maintains ordering)."
	(if xs
		(cons (car xs) (concat (cdr xs) ys))
			(if ys
				(cons (car ys) (concat xs (cdr ys)))
					nil)))

(impl:function concatn (lists)
	(do-concatn (car lists) (cdr lists)))

(impl:function do-concatn (list lists)
	(if list
		(cons (car list) (do-concatn (cdr list) lists))
		(if lists
			(do-concatn (car lists) (cdr lists))
			nil)))

(impl:function unquoted? (x)
	"Does x have the form (UNQUOTE ...)?"
	(if (list? x)
	    (= (car x) 'unquote)
	  nil))

(impl:function unquote-spliced? (x)
	"Does x have the form (UNQUOTE-SPLICING ...)?"
	(if (list? x)
	    (= (car x) 'unquote-splicing)
	  nil))

(impl:function do-quasiquote (x)
	"
	Takes any expression x and returns the quasiquoted result.
	Quasiquoting indicates that the given expression's quoting rules will be
	flipped. Any non-quoted expression will become quoted, and you must explicitly
	unquote expressions to indicate that they should be evaluated. There is a special
	case where you can indicate that an expression should be evaluated, and the value
	(which is a assumed to be a list) will be concatenated to the list it is contained in
	this is called UNQUOTE-SPLICING.

	Examples:
		(quasiquote 2) => (quote 2)
		(quasiquote (a b c)) => (quote (a b c))
		(quasiquote (unquote (my-function 1 2))) => (my-function 1 2)
		(quasiquote (list (unquote (+ 1 2)) 4)) => (list 3 (quote 4))
		(quasiquote (+ (unquote-splicing (list 1 2)))) => (+ 1 2)

	Note that the reader usually provides a special syntax for quasiquoting that looks like this:

	Examples (using quasiquoting syntax):
		`2 => 2
		`(a b c) => (a b c)
		`,(my-function 1 2) => (my-function 1 2)
		`(list ,(+ 1 2) 4) => (list 3 4)
		`(+ ,@(list 1 2)) => (+ 1 2)

	The implementation wraps all the values in an additional list to make it easier to
	apply a UNQUOTE-SPLICING.
	"
	(if (unquoted? x)
		     (list (cadr x))
		   (if (unquote-spliced? x)
		       (list (cadr x))
		     (if (cons? x)
				   	(list (concatn (mapcar (symbol-function 'do-quasiquote) x)))
		       (list (list 'quote x))))))

(impl:macro quasiquote (x)
	(car (do-quasiquote x)))

"FFI testing"
(set 'sdl2 (impl:dynamic-library "experiments/sdl/SDL2.dll"))

(set-symbol-function 'init
  (impl:foreign-function
  	sdl2 'SDL_Init
  	'ffi:int '(ffi:int)))

(set-symbol-function 'create-window
  (impl:foreign-function
  	sdl2 'SDL_CreateWindow
    'ffi:* '((ffi:* ffi:char) ffi:int ffi:int ffi:int ffi:int ffi:int)))

(set-symbol-function 'create-renderer
  (impl:foreign-function
  	sdl2 'SDL_CreateRenderer
    'ffi:* '(ffi:* ffi:int ffi:int)))

(set-symbol-function 'get-error
  (impl:foreign-function
  	sdl2 'SDL_GetError
    '(ffi:* ffi:char) '()))

(set-symbol-function 'rw-from-file
  (impl:foreign-function
  	sdl2 'SDL_RWFromFile
    'ffi:* '((ffi:* ffi:char) (ffi:* ffi:char))))

(set-symbol-function 'load-bmp-rw
  (impl:foreign-function
  	sdl2 'SDL_LoadBMP_RW
    'ffi:* '(ffi:* ffi:int)))

(set-symbol-function 'create-texture-from-surface
  (impl:foreign-function
  	sdl2 'SDL_CreateTextureFromSurface
    'ffi:* '(ffi:* ffi:*)))

(set-symbol-function 'render-clear
  (impl:foreign-function
  	sdl2 'SDL_RenderClear
    'ffi:* '(ffi:*)))

(set-symbol-function 'render-copy
  (impl:foreign-function
  	sdl2 'SDL_RenderCopy
    'ffi:* '(ffi:* ffi:* ffi:int ffi:int)))

(set-symbol-function 'render-present
  (impl:foreign-function
  	sdl2 'SDL_RenderPresent
    'ffi:* '(ffi:*)))

(set-symbol-function 'delay
  (impl:foreign-function
  	sdl2 'SDL_Delay
    'ffi:int '(ffi:int)))

(impl:function load-bmp (path)
	(let ((bmp-file (rw-from-file path "rb")))
		(load-bmp-rw bmp-file 1)))

(init 3)
(set 'win (create-window "Hello World!" 100 100 620 387 4))
(set 'ren (create-renderer win 1 2))
(set 'bmp (load-bmp "experiments/sdl/grumpy-cat.bmp"))
(set 'tex (create-texture-from-surface ren bmp))

(render-clear ren)
(render-copy ren tex 0 0)
(render-present ren)
(delay 3000)