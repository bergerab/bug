"
readtable-entry is a recursive structure (entries is supposed to be a list of itself).
But it is only ever used once recursively (for dispatch chars).
"
(struct readtable-entry
  ((char object)
   (function object)
   (entries object)))

(struct readtable
  ((entries object)))

(function char-code (str)
  (dynamic-byte-array-get str 0))

(setq *at-char-code* (char-code "@"))
(setq *rparen-char-code* (char-code ")"))
(setq *lparen-char-code* (char-code "("))
(setq *comma-char-code* (char-code ","))
(setq *single-quote-char-code* (char-code "'"))
(setq *0-char-code* (char-code "0"))
(setq *1-char-code* (char-code "1"))
(setq *2-char-code* (char-code "2"))
(setq *3-char-code* (char-code "3"))
(setq *4-char-code* (char-code "4"))
(setq *5-char-code* (char-code "5"))
(setq *6-char-code* (char-code "6"))
(setq *7-char-code* (char-code "7"))
(setq *8-char-code* (char-code "8"))
(setq *9-char-code* (char-code "9"))
(setq *space-char-code* (char-code " "))
(setq *tab-char-code* (char-code "\t"))
(setq *newline-char-code* (char-code "\n"))
(setq *return-char-code* (char-code "\r"))
(setq *tick-char-code* (char-code "`"))
(setq *double-quote-char-code* (char-code "\""))
(setq *semicolon-char-code* (char-code ";"))
(setq *backslash-char-code* (char-code "\\"))
(setq *n-char-code* (char-code "n"))
(setq *r-char-code* (char-code "r"))
(setq *t-char-code* (char-code "t"))
(setq *colon-char-code* (char-code ":"))

(setq *keyword-package* (find-package "keyword"))

(function make-readtable-entry (char func entries)
  (let ((entry (alloc readtable-entry)))
    (set-field entry char char)
    (set-field entry function func)
    (set-field entry entries entries)
    entry))

(function make-readtable ()
  (let ((readtable (alloc readtable)))
    (set-field readtable entries nil)
    readtable))

(setq *default-readtable* (make-readtable))
(setq *readtable* *default-readtable*)

(setq *end-of-input* '*end-of-input*)
(setq *file-name* nil)
(setq *file* nil)

(function copy-readtable ()
  (let ((readtable (alloc readtable)))
    (set-field readtable entries 
      (get-field (get-readtable) entries))
    readtable))

(function get-readtable ()
  "If *readtable* is set, yield that, otherwise yield the *default-readtable*."
  (if *readtable* *readtable* *default-readtable*))

(function set-macro-character (char f)
  (when *readtable*
    (set-field *readtable* entries 
      (cons (make-readtable-entry char f nil) (get-field *readtable* entries)))))

(function get-macro-character-entry (char)
  (when *readtable*
    (let ((entry (find entry (get-field *readtable* entries)
                    (= (get-field entry char) char))))
      (when entry entry))))

(function get-macro-character (char)
  (let ((entry (get-macro-character-entry char)))
    (when entry (get-field entry function))))

(function get-dispatch-macro-character-entry (disp-char sub-char)
  (let ((entry (get-macro-character-entry disp-char)))
    (when entry
      (let ((sub-entry (find e (get-field entry entries)
                          (= (get-field e char) sub-char))))
        (when sub-entry sub-entry)))))

(function get-dispatch-macro-character (disp-char sub-char)
  (let ((entry (get-dispatch-macro-character-entry disp-char sub-char)))
    (when entry (get-field entry function))))

(function set-dispatch-macro-character (disp-char sub-char f)
  (let ((entry (get-macro-character-entry disp-char)))
    (if entry 
        (set-field entry entries (cons (make-readtable-entry sub-char f nil) (get-field entry entries)))
      (set-macro-character disp-char nil)
      (set-field (get-macro-character-entry disp-char) entries (list (make-readtable-entry sub-char f nil))))))

(set-macro-character *tick-char-code*
  (function (stream char)
    (list 'quasiquote (read stream))))

(set-macro-character *comma-char-code*
  (function (stream char)
    (list 'unquote (read stream))))

(set-macro-character *single-quote-char-code*
  (function (stream char)
    (list 'quote (read stream))))

(set-macro-character *double-quote-char-code*
  (function (stream char) 
    "TODO: read string"
    (let ((lookahead nil)
          (buffer (dynamic-byte-array 100)))
      (while (progn 
                (set-local lookahead (read-peek stream))
                (not (or (= lookahead *double-quote-char-code*)
                         (= lookahead *end-of-input*))))
        (cond 
          ((= lookahead *backslash-char-code*)
            (progn 
              (read-char stream)
              (dynamic-byte-array-push buffer (handle-string-escape stream))))
          (t (dynamic-byte-array-push buffer (read-char stream)))))
      (when (= lookahead *double-quote-char-code*)
        (read-char stream))
      (dynamic-byte-array-as-string buffer))))

(function handle-string-escape (stream)
  (let ((char (read-char stream)))
    (cond 
      ((= char *end-of-input*) 
        (print "ERROR end of input during string escape"))
      ((= char *n-char-code*)
        *newline-char-code*)
      ((= char *r-char-code*)
        *return-char-code*)
      ((= char *double-quote-char-code*)
        *double-quote-char-code*)
      ((= char *t-char-code*)
        *tab-char-code*)
      ((= char *backslash-char-code*)
        *backslash-char-code*)
      (t (print "ERROR unknown escape code " char)))))

(set-macro-character *semicolon-char-code* 
  (function (stream char) 
    (let ((char nil))
      (while (progn 
                (set-local char (read-char stream))
                (not (or (= char *newline-char-code*)
                         (= char *end-of-input*))))
        nil)
      (read stream))))

(set-macro-character *lparen-char-code*
  (function (stream char)
    (let ((lookahead nil)
          (xs nil))
      (while (progn 
                (set-local lookahead (read-peek stream))
                (not (or (= lookahead *rparen-char-code*)
                         (= lookahead *end-of-input*))))
        (set-local xs (cons (read stream) xs))
        (skip-whitespace stream))
      (when (= lookahead *rparen-char-code*)
        (read-char stream)) 
      (reverse xs))))

(set-macro-character *rparen-char-code*
  (function (stream char)
    (print "UNEXPECTED RPAREN!")))

(set-dispatch-macro-character *comma-char-code* *at-char-code*
  (function (stream char)
    (list 'unquote-splicing (read stream))))

(function skip-whitespace (stream)
  (while (whitespace? (read-peek stream))
    (read-char stream)))

(function whitespace? (char)
  (or (= char *space-char-code*)
      (or (= char *tab-char-code*)
        (or (= char *newline-char-code*)
            (= char *return-char-code*)))))

(function numeric? (char)
  (and (>= char *0-char-code*)
       (<= char *9-char-code*)))

(function stream-has-macro? (stream)
  "Is the next char a macro character for a reader macro?"
  (get-macro-character (read-peek stream)))

(function stream-has-dispatch-macro? (stream)
  (get-dispatch-macro-character (read-peek stream) (read-peek-second stream)))

(function stream-has-whitespace? (stream)
  (whitespace? (read-peek stream)))

(function stream-ended? (stream)
  (= *end-of-input* (read-peek stream)))

(function read-peek (stream)
  "TODO: make version of byte-stream-peek that doesn't return a dba"
  (if (byte-stream-has stream)
    (byte-stream-peek-byte stream)
    *end-of-input*))

(function read-peek-second (stream)
  "TODO: make version of byte-stream-peek that doesn't return a dba"
  (if (byte-stream-has stream)
    (dynamic-byte-array-get (byte-stream-peek stream 2) 1)
    *end-of-input*))

(function read-char (stream)
  "TODO: make version of byte-stream-read that doesn't return a dba"
  (if (byte-stream-has stream)
    (dynamic-byte-array-get (byte-stream-read stream 1) 0)
    *end-of-input*))

(function stream-starts-with (stream f)
  (call f (read-peek stream)))

(function read-symbol (stream)
  (let ((buffer (dynamic-byte-array 50))
         (contains-number nil)
         (contains-single-colon nil)
         (contains-double-colon nil)
         (char nil)
         (previous-char nil))
    (skip-whitespace stream)
    (while (not (or 
                  (stream-has-whitespace? stream) 
                  (or (stream-ended? stream)
                      (stream-has-macro? stream))))
      (set-local char (read-char stream))
   
      (when (and (not contains-number) (numeric? char))
             (set-local contains-number t)) 

      (when (= char *colon-char-code*)
        (when contains-double-colon
          (print "ERROR symbol contains too many colons"))
        (if (= previous-char *colon-char-code*)
          (set-local contains-double-colon t)
         (if contains-single-colon
           (print "ERROR symbol contains too many colons")
          (set-local contains-single-colon t))))

      (dynamic-byte-array-push buffer char)
      (set-local previous-char char))
    (if contains-number
      (let ((n (parse-number (dynamic-byte-array-as-string buffer))))
        (if n
          n
          (string-to-symbol (dynamic-byte-array-as-string buffer) contains-single-colon contains-double-colon)))
     (string-to-symbol (dynamic-byte-array-as-string buffer) contains-single-colon contains-double-colon))))

(function string-to-symbol (string single-colon? double-colon?)
    "
    if A::B, INTERN symbol B into package A.
    if A:B, FIND-SYMBOL symbol B (must be exported) in package A.
    if B, INTERN symbol B into *PACKAGE*.
    if :B, INTERN symbol B in package KEYWORD.
    if ::B, INTERN symbol B in package KEYWORD.
    if A:B:C, error -- too many colons (this case was already caught in READ-SYMBOL).
    if A::B:C, error -- too many colons (this case was already caught in READ-SYMBOL).
    "
  (if (or single-colon? double-colon?)
    (let* ((package-and-symbol (split-package-from-symbol-name string))
           (package-name (car package-and-symbol))
           (symbol-name (cadr package-and-symbol))
           (keyword-package? (= package-name "")))
      (cond
        (keyword-package? (intern symbol-name *keyword-package*))
        (single-colon? (find-symbol symbol-name (find-package package-name)))
        (double-colon? (intern symbol-name (find-package package-name)))))
    (intern string *package*)))

(function split-package-from-symbol-name (string)
  "input must be of form X:Y or X::Y (X:Y:Z won't work -- X and Y can be empty string).
   TODO: this is a case where multiple return values would be good to implement"
  (let ((i 0)
        (advanced nil)
        (package-name (dynamic-byte-array 20))
        (symbol-name (dynamic-byte-array 50))
        (char nil)
        (length (dynamic-byte-array-length string)))
    (while (< i length)
      (set-local char (dynamic-byte-array-get string i))
      (if (= char *colon-char-code*)
        (set-local advanced t)
       (if advanced
        (dynamic-byte-array-push package-name char)
        (dynamic-byte-array-push symbol-name char)))
      (inc-local i))
    (list (dynamic-byte-array-as-string symbol-name) (dynamic-byte-array-as-string package-name))))

(function read (stream)
  (skip-whitespace stream)
  (let* ((char (read-peek stream))
         (reader (get-macro-character-entry char)))
    (if (= char *end-of-input*)
        (print "end of input was reached")
      (if reader
        (let ((dispatch-reader (stream-has-dispatch-macro? stream)))
          (if dispatch-reader
            (progn 
              (read-char stream)
              (call dispatch-reader stream (read-char stream)))
            (call (get-field reader function) stream (read-char stream))))
        (read-symbol stream)))))

(function digit-to-number (char)
  (cond 
    ((= char *0-char-code*) 0)
    ((= char *1-char-code*) 1)
    ((= char *2-char-code*) 2)
    ((= char *3-char-code*) 3)
    ((= char *4-char-code*) 4)
    ((= char *5-char-code*) 5)
    ((= char *6-char-code*) 6)
    ((= char *7-char-code*) 7)
    ((= char *8-char-code*) 8)
    ((= char *9-char-code*) 9)
    (t nil)))

(function parse-number (string)
  "Attempts to lift a string to a number -- if it can't, return nil."
  (let ((place 0)
        (i (- (dynamic-byte-array-length string) 1))
        (digit 0)
        (n 0)) 
    (while (and (>= i 0) digit)
      (set-local digit (digit-to-number (dynamic-byte-array-get string i)))
      (when digit
        (set-local n (+ n (* (pow 10 place) digit)))
        (inc-local place)
        (dec-local i)))
    (when digit n)))

(function read-entire-file (stream)
  (setq *file* stream)
  (let ((expr nil))
    (while (not (stream-ended? stream))
      (set-local expr (cons (read stream) expr)))
    (concat (list 'progn) (reverse expr))))