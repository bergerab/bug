"
readtable-entry is a recursive structure (entries is supposed to be a list of itself).
But it is only ever used once recursively (for dispatch chars).
"
(struct readtable-entry
  ((char object)
   (function object)
   (entries object)))

(struct readtable
  ((entries object)))

(setq *default-readtable* (make-readtable))
(setq *readtable* *default-readtable*)

(setq *end-of-input* '*end-of-input*)

(function make-readtable-entry (char func entries)
  (let ((entry (alloc readtable-entry)))
    (set-field entry char char)
    (set-field entry function func)
    (set-field entry entries entries)
    entry))

(function make-readtable ()
  (let ((readtable (alloc readtable)))
    (set-field readtable entries nil)
    readtable))

(function copy-readtable ()
  (let ((readtable (alloc readtable)))
    (set-field readtable entries 
      (get-field (get-readtable) entries))
    readtable))

(function get-readtable ()
  "If *readtable* is set, yield that, otherwise yield the *default-readtable*."
  (if *readtable* *readtable* *default-readtable*))

(function set-macro-character (char f)
  (when *readtable*
    (set-field *readtable* entries 
      (cons (make-readtable-entry char f nil) (get-field *readtable* entries)))))

(function get-macro-character-entry (char)
  (when *readtable*
    (let ((entry (find entry (get-field *readtable* entries)
                    (= (get-field entry char) char))))
      (when entry entry))))

(function get-macro-character (char)
  (let ((entry (get-macro-character-entry char)))
    (when entry (get-field entry function))))

(function get-dispatch-macro-character-entry (disp-char sub-char)
  (let ((entry (get-macro-character-entry disp-char)))
    (when entry
      (let ((sub-entry (find e (get-field entry entries)
                          (= (get-field e char) sub-char))))
        (when sub-entry sub-entry)))))

(function get-dispatch-macro-character (disp-char sub-char)
  (let ((entry (get-dispatch-macro-character-entry disp-char sub-char)))
    (when entry (get-field entry function))))

(function set-dispatch-macro-character (disp-char sub-char f)
  (let ((entry (get-macro-character-entry disp-char)))
    (if entry 
        (set-field entry entries (cons (make-readtable-entry sub-char f nil) (get-field entry entries)))
      (set-macro-character disp-char nil)
      (set-field (get-macro-character-entry disp-char) entries (list (make-readtable-entry sub-char f nil))))))

(set-macro-character (char-code "`")
  (function (stream char)
    (list 'quasiquote (read stream))))

(set-macro-character (char-code ",")
  (function (stream char)
    (list 'unquote (read stream))))

(set-macro-character (char-code "'")
  (function (stream char)
    (list 'quote (read stream))))

(set-macro-character (char-code "\"")
  (function (stream char) 
    "TODO: read string"
    (let ((lookahead nil)
          (buffer (dynamic-byte-array 100)))
      (while (progn 
                (set-local lookahead (read-peek stream))
                (not (or (= lookahead (char-code "\""))
                         (= lookahead *end-of-input*))))
        (cond 
          ((= lookahead (char-code "\\"))
            (progn 
              (read-char stream)
              (dynamic-byte-array-push buffer (handle-string-escape stream))))
          (t (dynamic-byte-array-push buffer (read-char stream)))))
      (when (= lookahead (char-code "\""))
        (read-char stream))
      (dynamic-byte-array-as-string buffer))))

(function handle-string-escape (stream)
  (let ((char (read-char stream)))
    (cond 
      ((= char *end-of-input*) 
        (print "ERROR end of input during string escape"))
      ((= char (char-code "n"))
        (char-code "\n"))
      ((= char (char-code "r"))
        (char-code "\r"))
      ((= char (char-code "\""))
        (char-code "\""))
      ((= char (char-code "t"))
        (char-code "\t"))
      ((= char (char-code "\\"))
        (char-code "\\"))
      (t (print "ERROR unknown escape code " char)))))

(set-macro-character (char-code ";")
  (function (stream char) 
    (let ((char nil))
      (while (progn 
                (set-local char (read-char stream))
                (not (or (= char (char-code "\n"))
                         (= char *end-of-input*))))
        nil)
      (read stream))))

(set-macro-character (char-code "(")
  (function (stream char)
    (let ((lookahead nil)
          (xs nil))
      (while (progn 
                (set-local lookahead (read-peek stream))
                (not (or (= lookahead (char-code ")"))
                         (= lookahead *end-of-input*))))
        (set-local xs (cons (read stream) xs))
        (skip-whitespace stream))
      (when (= lookahead (char-code ")"))
        (read-char stream)) 
      (reverse xs))))

(set-macro-character (char-code ")")
  (function (stream char)
    (print "UNEXPECTED RPAREN!")))

(set-dispatch-macro-character (char-code ",") (char-code "@")
  (function (stream char)
    (list 'unquote-splicing (read stream))))

(function char-code (str)
  (dynamic-byte-array-get str 0))

(setq *0-char-code* (char-code "0"))
(setq *9-char-code* (char-code "9"))
(setq *space-char-code* (char-code " "))
(setq *tab-char-code* (char-code "\t"))
(setq *newline-char-code* (char-code "\n"))
(setq *return-char-code* (char-code "\r"))

(function skip-whitespace (stream)
  (while (whitespace? (read-peek stream))
    (read-char stream)))

(function whitespace? (char)
  (or (= char *space-char-code*)
      (or (= char *tab-char-code*)
        (or (= char *newline-char-code*)
            (= char *return-char-code*)))))

(function numeric? (char)
  (and (>= char *0-char-code*)
       (<= char *9-char-code*)))

(function stream-has-macro? (stream)
  "Is the next char a macro character for a reader macro?"
  (get-macro-character (read-peek stream)))

(function stream-has-dispatch-macro? (stream)
  (get-dispatch-macro-character (read-peek stream) (read-peek-second stream)))

(function stream-has-whitespace? (stream)
  (whitespace? (read-peek stream)))

(function stream-ended? (stream)
  (= *end-of-input* (read-peek stream)))

(function symbol-char? (char)
  (and (>= char *0-char-code*)
       (<= char *9-char-code*)))

(function read-peek (stream)
  "TODO: make version of byte-stream-peek that doesn't return a dba"
  (if (byte-stream-has stream)
    (dynamic-byte-array-get (byte-stream-peek stream 1) 0)
    *end-of-input*))

(function read-peek-second (stream)
  "TODO: make version of byte-stream-peek that doesn't return a dba"
  (if (byte-stream-has stream)
    (dynamic-byte-array-get (byte-stream-peek stream 2) 1)
    *end-of-input*))

(function read-char (stream)
  "TODO: make version of byte-stream-read that doesn't return a dba"
  (if (byte-stream-has stream)
    (dynamic-byte-array-get (byte-stream-read stream 1) 0)
    *end-of-input*))

(function stream-starts-with (stream f)
  (f (read-peek stream)))

(function read-symbol (stream)
  (let ((buffer (dynamic-byte-array 100)))
    (skip-whitespace stream)
    (while (not (or 
                  (stream-has-whitespace? stream) 
                  (or (stream-ended? stream)
                      (stream-has-macro? stream))))
      (dynamic-byte-array-push buffer (read-char stream)))
    (intern (dynamic-byte-array-as-string buffer))))

(function read (stream)
  (skip-whitespace stream)
  (let* ((char (read-peek stream))
         (reader (get-macro-character-entry char)))
    (if (= char *end-of-input*)
        (print "end of input was reached")
      (if reader
        (let ((dispatch-reader (stream-has-dispatch-macro? stream)))
          (if dispatch-reader
            (progn 
              (read-char stream)
              (call dispatch-reader stream (read-char stream)))
            (call (get-field reader function) stream (read-char stream))))
        (read-symbol stream)))))

(function read-entire-file (stream)
  (let ((expr nil))
    (while (not (stream-ended? stream))
      (set-local expr (cons (read stream) expr)))
    (concat (list 'progn) (reverse expr))))

(setq self-input (open-file "main.bug" "r"))

(function test ()
  (read (byte-stream "(struct readtable-entry
     ((char object)
      (function object)
      (entries object)))")))