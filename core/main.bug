"Cons helpers that should probably be builtins"
(impl:define-function cadr (x)
	"Gets the second item in a list."
  (car (cdr x)))

(impl:define-function caddr (x)
	"Gets the third item in a list."
  (car (cdr (cdr x))))

(impl:define-function cadddr (x)
	"Gets the fourth item in a list."
  (car (cdr (cdr (cdr x)))))

(impl:define-function caddddr (x)
	"Gets the fifth item in a list."
  (car (cdr (cdr (cdr (cdr x))))))

(impl:define-function caar (x)
	"Gets the first item in the nested list of a list of lists."
  (car (car x)))

(impl:define-function cddr (x)
	"Skips the first two items in a list."
  (cdr (cdr x)))

(impl:define-function nil? (x)
	"Is x nil?"
	(= x nil))

(impl:define-function list? (x)
	"Is x a list (either cons cell or nil)?"
    (or (= (type-of x) (symbol-type 'cons))
        (= x nil)))

(impl:define-function cons? (x)
	"Is x a cons cell?"
    (= (type-of x) (symbol-type 'cons)))

(impl:define-function mapcar (f xs)
	"Applies f to each item in the list xs and returns a new list containing the yielded values."
	(if xs
		(cons (call f (car xs)) 
				  (mapcar f (cdr xs)))
		nil))

(impl:define-function concat (xs ys)
	"Creates a new single list that contains all items in xs followed by all items in ys (maintains ordering)."
	(if xs
		(cons (car xs) (concat (cdr xs) ys))
			(if ys
				(cons (car ys) (concat xs (cdr ys)))
					nil)))

(impl:define-function concatn (lists)
	(do-concatn (car lists) (cdr lists)))

(impl:define-function do-concatn (list lists)
	(if list
		(cons (car list) (do-concatn (cdr list) lists))
		(if lists
			(do-concatn (car lists) (cdr lists))
			nil)))

(impl:define-function unquoted? (x)
	"Does x have the form (UNQUOTE ...)?"
	(if (list? x)
	    (= (car x) 'unquote)
	  nil))

(impl:define-function unquote-spliced? (x)
	"Does x have the form (UNQUOTE-SPLICING ...)?"
	(if (list? x)
	    (= (car x) 'unquote-splicing)
	  nil))

(impl:define-function do-quasiquote (x)
	"
	Takes any expression x and returns the quasiquoted result.
	Quasiquoting indicates that the given expression's quoting rules will be
	flipped. Any non-quoted expression will become quoted, and you must explicitly
	unquote expressions to indicate that they should be evaluated. There is a special
	case where you can indicate that an expression should be evaluated, and the value
	(which is a assumed to be a list) will be concatenated to the list it is contained in
	this is called UNQUOTE-SPLICING.

	Examples:
		(quasiquote 2) => (quote 2)
		(quasiquote (a b c)) => (quote (a b c))
		(quasiquote (unquote (my-function 1 2))) => (my-function 1 2)
		(quasiquote (list (unquote (+ 1 2)) 4)) => (list 3 (quote 4))
		(quasiquote (+ (unquote-splicing (list 1 2)))) => (+ 1 2)

	Note that the reader usually provides a special syntax for quasiquoting that looks like this:

	Examples (using quasiquoting syntax):
		`2 => 2
		`(a b c) => (a b c)
		`,(my-function 1 2) => (my-function 1 2)
		`(list ,(+ 1 2) 4) => (list 3 4)
		`(+ ,@(list 1 2)) => (+ 1 2)

	The implementation wraps all the values in an additional list to make it easier to
	apply a UNQUOTE-SPLICING.
	"
	(if (unquoted? x)
 	 (list 'list (cadr x))
   (if (unquote-spliced? x)
     (cadr x)
     (if (cons? x)
	     (list 'list (concat (list 'concatn) (list (concat (list 'list) (mapcar (symbol-function 'do-quasiquote) x)))))
       (list 'list (list 'quote x))))))

(macro quasiquote (x)
	(cadr (do-quasiquote x)))

(macro when args
	`(if ,(car args)
			(progn 
				,@(cdr args))
				nil))

(macro unless args
	`(when (= nil ,(car args)) 
			,@(cdr args)))

(macro setq (sym val)
	`(set ',sym ,val))

(macro make (type)
	`(alloc-struct ',type))

(macro setf (instance field value)
	`(set-struct-field ,instance ',field , value))

(macro getf (instance field)
	`(struct-field ,instance ',field))

(macro incf (instance field)
	`(setf ,instance ,field (+ 1 (getf ,instance ,field))))

(macro decf (instance field)
	`(setf ,instance ,field (+ 1 (getf ,instance ,field))))

(macro incq (sym)
	`(setq ,sym (+ 1 ,sym)))

(macro decq (sym)
	`(setq ,sym (- ,sym 1)))

(macro function args
	`(impl:define-function ,@args))

(macro print-return (x)
	`(let ((i-need-to-implement-gensym ,x))
		(print i-need-to-implement-gensym)
		i-need-to-implement-gensym))

(macro struct (name fields)
	`(impl:define-struct ',name ',fields))

(function mapcar-with-carry (f xs carry)
	"mapcar with a value that is carried to the function -- a total hack should be removed when bug compiler is done (using closures or builtin looping constructs)"
	(when xs
		(cons (call f (car xs) carry) 
				  (mapcar-with-carry f (cdr xs) carry))))

(function with-fields-format-field (field instance)
	`(,field (getf ,instance ,field)))
(macro with-fields args
	(let ((fields (cadr args))
	      (instance (car args))
				(body (cddr args)))
			`(let ((i-need-to-implement-gensym-real-bad ,instance)) 
					(let (,@(mapcar-with-carry (symbol-function 'with-fields-format-field) fields 'i-need-to-implement-gensym-real-bad))
    				,@body))))

(macro collect args
	`(mapcar (function (,(car args)) ,@(cddr args)) ,(cadr args)))

(macro for-each args
	`(do-for-each (function (,(car args)) ,@(cddr args)) ,(cadr args)))

(function reduce (f xs acc)
	(if xs (reduce f (cdr xs) (call f acc (car xs))) acc))

"TODO: make macroexpand builtin"

"===================== misc =========================="
(function fib (x)
  (if (< x 2)
    x
    (+ (fib (- x 2)) 
       (fib (- x 1)))))
"====================================================="

(function do-filter (f xs)
	(when xs
		(if (call f (car xs))
			(cons (car xs) (do-filter f (cdr xs)))
			(do-filter f (cdr xs)))))

(macro filter args
	`(do-filter (function (,(car args)) ,@(cddr args)) ,(cadr args)))

(function do-any (f xs)
	(when xs
		(if (call f (car xs))
			t
			(do-any f (cdr xs)))))

(function do-all (f xs)
	(if xs
		(when (call f (car xs))
			(do-all f (cdr xs)))
		t))

(macro all args
	`(do-all (function (,(car args)) ,@(cddr args)) ,(cadr args)))

(macro any args
	`(do-any (function (,(car args)) ,@(cddr args)) ,(cadr args)))

(function do-for-each (f xs)
	(when xs
		(call f (car xs))
		(do-for-each f (cdr xs))))

(function in (y xs)
	(when xs
		(if (= y (car xs))
			t
			(in y (cdr xs)))))

(macro is (type-name object)
    `(= (type-of ,object) (symbol-type ',type-name)))

(function string-join (xs str)
	(if (cadr xs) 
		(string-concat (string-concat (car xs) str) (string-join (cdr xs) str))
		(if (car xs)
			(car xs)
			"")))

(function string-concat args
	(if args
		(if (cdr args)
		(reduce (function (a b) (impl:string-concat a b)) (cdr args) (car args))
		(car args))
		""))

(function do-times (f n)
	(when (> n 0)
		(call f)
		(do-times f (- n 1))))

(function count-down (from to)
	(when (>= from to)
		(cons from (count-down (- from 1) to))))

(function count-up (from to)
	(when (<= from to)
		(cons from (count-up (+ from 1) to))))

(function repeat (x n)
	(when (> n 0)
		(cons x (repeat x (- n 1)))))

(function string-times (str n)
	(apply 'string-concat (repeat str n)))

(struct rect
	((x int) (y int) (w int) (h int)))

(function struct-test ()
	(setq rect (make rect))
	(setf rect x 10)
	(setf rect y 20)
	(setf rect w 200)
	(setf rect h 100)

	(print rect)

	(print (getf rect x))
	(print (getf rect y))
	(print (getf rect w))
	(print (getf rect h))
	(setf rect w 3)
	(print (getf rect w)))

(function advanced-struct-test ()
  (struct b
   ((z int)
    (a int)
  	(b int)
  	(c int)
  	(d int)))
  
" TODO: this should be OK to say (pointer b)"
  (struct a
   ((x int) 
    (y (pointer b))))
  
  (make a)
  (getf (make a) y))

(function list-of-lists? (xs)
  (when (list? xs)
    (all x xs 
      (list? x))))

(function out-of-bounds (xs x)
	(or (< x 0)
		  (>= x (dynamic-array-length xs))))

(function string-quote (x)
  (string-concat "\"" x  "\""))

(function load (path)
	(let ((file (open-file path "rb")))
		(let ((f (compile-entire-file file)))
			(call f))))

(impl:change-directory "../lib/sdl2")
(load "main.bug")

(impl:change-directory "../html")
(load "main.bug")

(impl:change-directory "../json")
(load "main.bug")

(impl:change-directory "../disassembler")
(load "main.bug")